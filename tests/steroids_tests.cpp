#include <algorithm>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <assert.h>
#include <string>
#include <tuple>
#include <vector>

#include "steroids.hpp"
#include "util.hpp"

const std::string ansi_green = "\033[0;32m";
const std::string ansi_white = "\033[0;97m";

class SteroidsTests {
public:
    static void InsertionTest() {
        const uint32_t infix_size = 5;
        const uint32_t seed = 1;
        const float load_factor = 0.95;
        Steroids s(infix_size, seed, load_factor);

        uint64_t value;
        char buf[9];
        memset(buf, 0, sizeof(buf));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000011111111ULL));
        s.AddTreeKey(reinterpret_cast<char *>(&value), sizeof(value));
        auto it = s.tree_.begin(reinterpret_cast<char *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000022222222ULL));
        s.AddTreeKey(reinterpret_cast<char *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000033333333ULL));
        s.AddTreeKey(reinterpret_cast<char *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000044444444ULL));
        s.AddTreeKey(reinterpret_cast<char *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000020000000ULL));
        s.Insert(reinterpret_cast<char *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000040007777ULL));
        s.Insert(reinterpret_cast<char *>(&value), sizeof(value));

        for (int32_t i = 1; i < 100; i++) {
            const uint64_t l = 0x0000000011111111ULL, r = 0x0000000022222222ULL;
            const uint64_t interp = (l * i + r * (100 - i)) / 100;
            value = to_big_endian_order(interp);
            s.Insert(reinterpret_cast<char *>(&value), sizeof(value));
        }
        {
            const std::vector<uint32_t> occupieds_pos = {2, 5, 8, 10, 13, 16,
                19, 21, 24, 27, 30, 32, 35, 38, 41, 43, 46, 49, 51, 54, 57, 60,
                62, 65, 68, 71, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101,
                103, 106, 109, 112, 114, 117, 120, 122, 125, 128, 131, 133,
                136, 139, 142, 144, 147, 150, 152, 155, 158, 161, 163, 166,
                169, 172, 174, 177, 180, 183, 185, 188, 191, 193, 196, 199,
                202, 204, 207, 210, 213, 215, 218, 221, 223, 226, 229, 232,
                234, 237, 239, 240, 243, 245, 248, 251, 254, 256, 259, 262,
                264, 267, 270};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
               {{3,1,0b11001}, {9,1,0b10001}, {15,1,0b01001}, {19,1,0b11111},
                   {25,1,0b10111}, {31,1,0b01111}, {37,1,0b00101},
                   {41,1,0b11101}, {47,1,0b10101}, {53,1,0b01011},
                   {59,1,0b00011}, {62,1,0b11011}, {68,1,0b10011},
                   {74,1,0b01001}, {80,1,0b00001}, {84,1,0b11001},
                   {90,1,0b01111}, {96,1,0b00111}, {100,1,0b11111},
                   {106,1,0b10101}, {112,1,0b01101}, {118,1,0b00101},
                   {121,1,0b11011}, {127,1,0b10011}, {133,1,0b01011},
                   {139,1,0b00011}, {143,1,0b11001}, {149,1,0b10001},
                   {155,1,0b01001}, {159,1,0b11111}, {165,1,0b10111},
                   {171,1,0b01111}, {177,1,0b00101}, {180,1,0b11101},
                   {186,1,0b10101}, {192,1,0b01011}, {198,1,0b00011},
                   {202,1,0b11011}, {208,1,0b10011}, {214,1,0b01001},
                   {220,1,0b00001}, {224,1,0b11001}, {230,1,0b01111},
                   {236,1,0b00111}, {239,1,0b11111}, {245,1,0b10101},
                   {251,1,0b01101}, {257,1,0b00101}, {261,1,0b11011},
                   {267,1,0b10011}, {273,1,0b01011}, {279,1,0b00001},
                   {283,1,0b11001}, {289,1,0b10001}, {295,1,0b01001},
                   {298,1,0b11111}, {304,1,0b10111}, {310,1,0b01111},
                   {316,1,0b00101}, {320,1,0b11101}, {326,1,0b10101},
                   {332,1,0b01011}, {338,1,0b00011}, {342,1,0b11011},
                   {348,1,0b10001}, {354,1,0b01001}, {359,1,0b00001},
                   {363,1,0b11001}, {369,1,0b01111}, {375,1,0b00111},
                   {379,1,0b11111}, {385,1,0b10101}, {391,1,0b01101},
                   {397,1,0b00101}, {401,1,0b11011}, {407,1,0b10011},
                   {413,1,0b01011}, {418,1,0b00001}, {422,1,0b11001},
                   {428,1,0b10001}, {434,1,0b01001}, {438,1,0b11111},
                   {444,1,0b10111}, {450,1,0b01111}, {456,1,0b00101},
                   {460,1,0b11101}, {466,1,0b10101}, {470,1,0b00001},
                   {472,1,0b01011}, {477,1,0b00011}, {481,1,0b11011},
                   {487,1,0b10001}, {493,1,0b01001}, {499,1,0b00001},
                   {503,1,0b10111}, {509,1,0b01111}, {515,1,0b00111},
                   {519,1,0b11111}, {525,1,0b10101}, {531,1,0b01101}};
            AssertStoreContents(s, it.ref(), occupieds_pos, checks);
        }

        for (int32_t i = 90; i >= 70; i -= 2) {
            const uint64_t l = 0x0000000011111111ULL, r = 0x0000000022222222ULL;
            const uint64_t interp = (l * i + r * (100 - i)) / 100;
            value = to_big_endian_order(interp);
            s.Insert(reinterpret_cast<char *>(&value), sizeof(value));
        }
        {
            const std::vector<uint32_t> occupieds_pos = {2, 5, 8, 10, 13, 16,
                19, 21, 24, 27, 30, 32, 35, 38, 41, 43, 46, 49, 51, 54, 57, 60,
                62, 65, 68, 71, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101,
                103, 106, 109, 112, 114, 117, 120, 122, 125, 128, 131, 133,
                136, 139, 142, 144, 147, 150, 152, 155, 158, 161, 163, 166,
                169, 172, 174, 177, 180, 183, 185, 188, 191, 193, 196, 199,
                202, 204, 207, 210, 213, 215, 218, 221, 223, 226, 229, 232,
                234, 237, 239, 240, 243, 245, 248, 251, 254, 256, 259, 262,
                264, 267, 270};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                  {{3,1,0b11001}, {9,1,0b10001}, {15,1,0b01001},
                      {19,1,0b11111}, {25,1,0b10111}, {31,1,0b01111},
                      {37,1,0b00101}, {41,1,0b11101}, {47,1,0b10101},
                      {53,0,0b01011}, {54,1,0b01011}, {59,1,0b00011},
                      {62,0,0b11011}, {63,1,0b11011}, {68,1,0b10011},
                      {74,0,0b01001}, {75,1,0b01001}, {80,1,0b00001},
                      {84,0,0b11001}, {85,1,0b11001}, {90,1,0b01111},
                      {96,0,0b00111}, {97,1,0b00111}, {100,1,0b11111},
                      {106,0,0b10101}, {107,1,0b10101}, {112,1,0b01101},
                      {118,0,0b00101}, {119,1,0b00101}, {121,1,0b11011},
                      {127,0,0b10011}, {128,1,0b10011}, {133,1,0b01011},
                      {139,0,0b00011}, {140,1,0b00011}, {143,1,0b11001},
                      {149,0,0b10001}, {150,1,0b10001}, {155,1,0b01001},
                      {159,0,0b11111}, {160,1,0b11111}, {165,1,0b10111},
                      {171,1,0b01111}, {177,1,0b00101}, {180,1,0b11101},
                      {186,1,0b10101}, {192,1,0b01011}, {198,1,0b00011},
                      {202,1,0b11011}, {208,1,0b10011}, {214,1,0b01001},
                      {220,1,0b00001}, {224,1,0b11001}, {230,1,0b01111},
                      {236,1,0b00111}, {239,1,0b11111}, {245,1,0b10101},
                      {251,1,0b01101}, {257,1,0b00101}, {261,1,0b11011},
                      {267,1,0b10011}, {273,1,0b01011}, {279,1,0b00001},
                      {283,1,0b11001}, {289,1,0b10001}, {295,1,0b01001},
                      {298,1,0b11111}, {304,1,0b10111}, {310,1,0b01111},
                      {316,1,0b00101}, {320,1,0b11101}, {326,1,0b10101},
                      {332,1,0b01011}, {338,1,0b00011}, {342,1,0b11011},
                      {348,1,0b10001}, {354,1,0b01001}, {359,1,0b00001},
                      {363,1,0b11001}, {369,1,0b01111}, {375,1,0b00111},
                      {379,1,0b11111}, {385,1,0b10101}, {391,1,0b01101},
                      {397,1,0b00101}, {401,1,0b11011}, {407,1,0b10011},
                      {413,1,0b01011}, {418,1,0b00001}, {422,1,0b11001},
                      {428,1,0b10001}, {434,1,0b01001}, {438,1,0b11111},
                      {444,1,0b10111}, {450,1,0b01111}, {456,1,0b00101},
                      {460,1,0b11101}, {466,1,0b10101}, {470,1,0b00001},
                      {472,1,0b01011}, {477,1,0b00011}, {481,1,0b11011},
                      {487,1,0b10001}, {493,1,0b01001}, {499,1,0b00001},
                      {503,1,0b10111}, {509,1,0b01111}, {515,1,0b00111},
                      {519,1,0b11111}, {525,1,0b10101}, {531,1,0b01101}};
            AssertStoreContents(s, it.ref(), occupieds_pos, checks);
        }

        uint32_t shamt = 16;
        for (int32_t i = 1; i < 50; i++) {
            const uint64_t l = 0x0000000011111111ULL, r = 0x0000000022222222ULL;
            value = to_big_endian_order((l * 30 + r * 70) / 100 + (i << shamt));
            s.Insert(reinterpret_cast<char *>(&value), sizeof(value));
        }
        {
            const std::vector<uint32_t> occupieds_pos = {2, 5, 8, 10, 13, 16,
                19, 21, 24, 27, 30, 32, 35, 38, 41, 43, 46, 49, 51, 54, 57, 60,
                62, 65, 68, 71, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101,
                103, 106, 109, 112, 114, 117, 120, 122, 125, 128, 131, 133,
                136, 139, 142, 144, 147, 150, 152, 155, 158, 161, 163, 166,
                169, 172, 174, 177, 180, 183, 185, 188, 191, 192, 193, 194,
                196, 199, 202, 204, 207, 210, 213, 215, 218, 221, 223, 226,
                229, 232, 234, 237, 239, 240, 243, 245, 248, 251, 254, 256,
                259, 262, 264, 267, 270};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{3,1,0b11001}, {9,1,0b10001}, {15,1,0b01001}, {19,1,0b11111},
                     {25,1,0b10111}, {31,1,0b01111}, {37,1,0b00101},
                     {41,1,0b11101}, {47,1,0b10101}, {53,0,0b01011},
                     {54,1,0b01011}, {59,1,0b00011}, {62,0,0b11011},
                     {63,1,0b11011}, {68,1,0b10011}, {74,0,0b01001},
                     {75,1,0b01001}, {80,1,0b00001}, {84,0,0b11001},
                     {85,1,0b11001}, {90,1,0b01111}, {96,0,0b00111},
                     {97,1,0b00111}, {100,1,0b11111}, {106,0,0b10101},
                     {107,1,0b10101}, {112,1,0b01101}, {118,0,0b00101},
                     {119,1,0b00101}, {121,1,0b11011}, {127,0,0b10011},
                     {128,1,0b10011}, {133,1,0b01011}, {139,0,0b00011},
                     {140,1,0b00011}, {143,1,0b11001}, {149,0,0b10001},
                     {150,1,0b10001}, {155,1,0b01001}, {159,0,0b11111},
                     {160,1,0b11111}, {165,1,0b10111}, {171,1,0b01111},
                     {177,1,0b00101}, {180,1,0b11101}, {186,1,0b10101},
                     {192,1,0b01011}, {198,1,0b00011}, {202,1,0b11011},
                     {208,1,0b10011}, {214,1,0b01001}, {220,1,0b00001},
                     {224,1,0b11001}, {230,1,0b01111}, {236,1,0b00111},
                     {239,1,0b11111}, {245,1,0b10101}, {251,1,0b01101},
                     {257,1,0b00101}, {261,1,0b11011}, {267,1,0b10011},
                     {273,1,0b01011}, {279,1,0b00001}, {283,1,0b11001},
                     {289,1,0b10001}, {295,1,0b01001}, {298,1,0b11111},
                     {304,1,0b10111}, {310,1,0b01111}, {316,1,0b00101},
                     {320,1,0b11101}, {326,1,0b10101}, {332,1,0b01011},
                     {338,1,0b00011}, {342,1,0b11011}, {348,1,0b10001},
                     {354,1,0b01001}, {359,1,0b00001}, {363,1,0b11001},
                     {369,1,0b01111}, {375,0,0b00111}, {376,0,0b01001},
                     {377,0,0b01011}, {378,0,0b01101}, {379,0,0b01111},
                     {380,0,0b10001}, {381,0,0b10011}, {382,0,0b10101},
                     {383,0,0b10111}, {384,0,0b11001}, {385,0,0b11011},
                     {386,0,0b11101}, {387,1,0b11111}, {388,0,0b00001},
                     {389,0,0b00011}, {390,0,0b00101}, {391,0,0b00111},
                     {392,0,0b01001}, {393,0,0b01011}, {394,0,0b01101},
                     {395,0,0b01111}, {396,0,0b10001}, {397,0,0b10011},
                     {398,0,0b10101}, {399,0,0b10111}, {400,0,0b11001},
                     {401,0,0b11011}, {402,0,0b11101}, {403,1,0b11111},
                     {404,0,0b00001}, {405,0,0b00011}, {406,0,0b00101},
                     {407,0,0b00111}, {408,0,0b01001}, {409,0,0b01011},
                     {410,0,0b01101}, {411,0,0b01111}, {412,0,0b10001},
                     {413,0,0b10011}, {414,0,0b10101}, {415,0,0b10111},
                     {416,0,0b11001}, {417,0,0b11011}, {418,0,0b11101},
                     {419,0,0b11111}, {420,1,0b11111}, {421,0,0b00001},
                     {422,0,0b00011}, {423,0,0b00101}, {424,0,0b00111},
                     {425,1,0b01001}, {426,1,0b10101}, {427,1,0b01101},
                     {428,1,0b00101}, {429,1,0b11011}, {430,1,0b10011},
                     {431,1,0b01011}, {432,1,0b00001}, {433,1,0b11001},
                     {434,1,0b10001}, {435,1,0b01001}, {438,1,0b11111},
                     {444,1,0b10111}, {450,1,0b01111}, {456,1,0b00101},
                     {460,1,0b11101}, {466,1,0b10101}, {470,1,0b00001},
                     {472,1,0b01011}, {477,1,0b00011}, {481,1,0b11011},
                     {487,1,0b10001}, {493,1,0b01001}, {499,1,0b00001},
                     {503,1,0b10111}, {509,1,0b01111}, {515,1,0b00111},
                     {519,1,0b11111}, {525,1,0b10101}, {531,1,0b01101}};
            AssertStoreContents(s, it.ref(), occupieds_pos, checks);
        }

        value = (0x0000000011111111ULL * 30 + 0x0000000022222222ULL * 70) / 100 + (8ULL << shamt);
        value = to_big_endian_order(value);
        s.InsertSplitInfixStore(reinterpret_cast<char *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000011111111ULL));
        it = s.tree_.begin(reinterpret_cast<char *>(&value), sizeof(value));
        {
            const std::vector<uint32_t> occupieds_pos = {5, 11, 16, 21, 27, 32,
                38, 43, 49, 54, 60, 65, 71, 76, 82, 87, 92, 98, 103, 109, 114,
                120, 125, 131, 136, 142, 147, 153, 158, 163, 169, 174, 180,
                185, 191, 196, 202, 207, 213, 218, 224, 229, 234, 240, 245,
                251, 256, 262, 267, 273, 278, 284, 289, 295, 300, 305, 311,
                316, 322, 327, 333, 338, 344, 349, 355, 360, 366, 371, 376,
                382, 383};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{7,1,0b10010}, {15,1,0b00010}, {22,1,0b10010},
                     {29,1,0b11110}, {37,1,0b01110}, {44,1,0b11110},
                     {53,1,0b01010}, {60,1,0b11010}, {68,1,0b01010},
                     {75,0,0b10110}, {76,1,0b10110}, {84,1,0b00110},
                     {91,0,0b10110}, {92,1,0b10110}, {99,1,0b00110},
                     {106,0,0b10010}, {107,1,0b10010}, {115,1,0b00010},
                     {122,0,0b10010}, {123,1,0b10010}, {129,1,0b11110},
                     {137,0,0b01110}, {138,1,0b01110}, {144,1,0b11110},
                     {152,0,0b01010}, {153,1,0b01010}, {159,1,0b11010},
                     {168,0,0b01010}, {169,1,0b01010}, {175,1,0b10110},
                     {183,0,0b00110}, {184,1,0b00110}, {190,1,0b10110},
                     {199,0,0b00110}, {200,1,0b00110}, {206,1,0b10010},
                     {214,0,0b00010}, {215,1,0b00010}, {221,1,0b10010},
                     {228,0,0b11110}, {229,1,0b11110}, {237,1,0b01110},
                     {244,1,0b11110}, {252,1,0b01010}, {259,1,0b11010},
                     {268,1,0b01010}, {275,1,0b10110}, {283,1,0b00110},
                     {290,1,0b10110}, {298,1,0b00110}, {305,1,0b10010},
                     {314,1,0b00010}, {321,1,0b10010}, {328,1,0b11110},
                     {336,1,0b01110}, {343,1,0b11110}, {352,1,0b01010},
                     {359,1,0b11010}, {367,1,0b01010}, {374,1,0b10110},
                     {383,1,0b00110}, {390,1,0b10110}, {398,1,0b00010},
                     {405,1,0b10010}, {414,1,0b00010}, {421,1,0b10010},
                     {428,1,0b11110}, {436,1,0b01110}, {443,1,0b11110},
                     {451,1,0b01010}, {458,1,0b11010}, {467,1,0b01010},
                     {474,1,0b10110}, {482,1,0b00110}, {489,1,0b10110},
                     {498,1,0b00010}, {505,1,0b10010}, {513,1,0b00010},
                     {520,1,0b10010}, {527,1,0b11110}, {530,0,0b01110},
                     {531,0,0b10010}, {532,0,0b10110}, {533,0,0b11010},
                     {534,1,0b11110}, {535,0,0b00010}, {536,0,0b00110},
                     {537,1,0b01010}};
            auto store = it.ref();
            assert(!store.IsPartialKey());
            assert(store.GetInvalidBits() == 0);
            AssertStoreContents(s, store, occupieds_pos, checks);
        }


        value = (0x0000000011111111ULL * 30 + 0x0000000022222222ULL * 70) / 100 + (8ULL << shamt);
        value &= ~BITMASK(shamt);
        value = to_big_endian_order(value);
        it = s.tree_.begin(reinterpret_cast<char *>(&value), sizeof(value) - shamt / 8);
        {
            const std::vector<uint32_t> occupieds_pos = {0, 1, 2, 3, 4, 5, 6,
                7, 8, 9, 10, 11, 20, 31, 42, 53, 64, 75, 86, 97, 108, 119, 129,
                140, 151, 162, 173, 184, 190, 195, 206, 217, 228, 239, 250,
                260, 271, 282, 293, 304, 315};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{0,1,0b11001}, {1,0,0b00100}, {2,0,0b01100}, {3,0,0b10100},
                     {4,1,0b11100}, {6,0,0b00100}, {7,0,0b01100},
                     {8,0,0b10100}, {9,1,0b11100}, {11,0,0b00100},
                     {12,0,0b01100}, {13,0,0b10100}, {14,1,0b11100},
                     {16,0,0b00100}, {17,0,0b01100}, {18,0,0b10100},
                     {19,1,0b11100}, {21,0,0b00100}, {22,0,0b01100},
                     {23,0,0b10100}, {24,1,0b11100}, {26,0,0b00100},
                     {27,0,0b01100}, {28,0,0b10100}, {29,1,0b11100},
                     {31,0,0b00100}, {32,0,0b01100}, {33,0,0b10100},
                     {34,1,0b11100}, {36,0,0b00100}, {37,0,0b01100},
                     {38,0,0b10100}, {39,1,0b11100}, {41,0,0b00100},
                     {42,0,0b01100}, {43,0,0b10100}, {44,0,0b11100},
                     {45,1,0b11100}, {47,0,0b00100}, {48,0,0b01100},
                     {49,0,0b10100}, {50,1,0b11100}, {52,1,0b00100},
                     {54,1,0b10100}, {56,1,0b10100}, {69,1,0b10100},
                     {87,1,0b01100}, {105,1,0b01100}, {123,1,0b01100},
                     {141,1,0b00100}, {159,1,0b00100}, {177,1,0b00100},
                     {196,1,0b00100}, {212,1,0b11100}, {230,1,0b11100},
                     {248,1,0b11100}, {266,1,0b10100}, {285,1,0b10100},
                     {303,1,0b10100}, {313,1,0b00100}, {321,1,0b01100},
                     {339,1,0b01100}, {357,1,0b01100}, {375,1,0b00100},
                     {393,1,0b00100}, {412,1,0b00100}, {428,1,0b11100},
                     {446,1,0b11100}, {464,1,0b11100}, {482,1,0b11100},
                     {501,1,0b10100}, {519,1,0b10100}};
            auto store = it.ref();
            assert(store.IsPartialKey());
            assert(store.GetInvalidBits() == 7);
            AssertStoreContents(s, store, occupieds_pos, checks);
        }


        std::cerr << "old_boundary=";
        print_key(it.key().c_str(), it.key().size(), true);

        // Split an extension of a boundary key
        value = (0x0000000011111111ULL * 30 + 0x0000000022222222ULL * 70) / 100 + (8ULL << shamt);
        value &= ~BITMASK(shamt);
        value += 1;
        value = to_big_endian_order(value);
        std::cerr << "WEIRD SPLIT key=";
        print_key(reinterpret_cast<char *>(&value), sizeof(value), true);
        s.InsertSplitInfixStore(reinterpret_cast<char *>(&value), sizeof(value));

        value = (0x0000000011111111ULL * 30 + 0x0000000022222222ULL * 70) / 100 + (8ULL << shamt);
        value &= ~BITMASK(shamt);
        value = to_big_endian_order(value);
        it = s.tree_.begin(reinterpret_cast<char *>(&value), sizeof(value) - shamt / 8);
        print_key(it.key().c_str(), it.key().size());
        PrintStore(s, it.ref());
        it++;
        print_key(it.key().c_str(), it.key().size());
        PrintStore(s, it.ref());
    }

private:
    static void AssertStoreContents(const Steroids &s, const Steroids::InfixStore &store,
                                    const std::vector<uint32_t> &occupieds_pos,
                                    const std::vector<std::tuple<uint32_t, bool, uint64_t>> &checks) {
        assert(store.ptr != nullptr);
        assert(store.GetElemCount() == checks.size());
        const uint64_t *occupieds = store.ptr;
        const uint64_t *runends = store.ptr + Steroids::infix_store_target_size / 64;
        uint32_t ind = 0;
        for (uint32_t i = 0; i < Steroids::infix_store_target_size; i++) {
            if (ind < occupieds_pos.size() && i == occupieds_pos[ind]) {
                assert(get_bitmap_bit(occupieds, i));
                ind++;
            }
            else 
                assert(!get_bitmap_bit(occupieds, i));
        }

        const uint32_t total_size = s.scaled_sizes_[store.GetSizeGrade()];
        ind = 0;
        uint32_t runend_count = 0;
        for (int32_t i = 0; i < total_size; i++) {
            const uint64_t slot = s.GetSlot(store, i);
            if (ind < checks.size()) {
                const auto [pos, runend, value] = checks[ind];
                if (i == pos) {
                    assert(value == slot);
                    assert(get_bitmap_bit(runends, i) == runend);
                    runend_count += runend;
                    ind++;
                }
                else {
                    assert(slot == 0ULL);
                    assert(!get_bitmap_bit(runends, i));
                }
            }
            else {
                assert(slot == 0ULL);
                assert(!get_bitmap_bit(runends, i));
            }
        }
        assert(occupieds_pos.size() == runend_count);
    }


    static void PrintStore(const Steroids &s, const Steroids::InfixStore &store) {
        const uint32_t size_grade = store.GetSizeGrade();
        const uint64_t *occupieds = store.ptr;
        const uint64_t *runends = store.ptr + Steroids::infix_store_target_size / 64;

        std::cerr << "is_partial=" << store.IsPartialKey() << " invalid_bits=" << store.GetInvalidBits();
        std::cerr << " size_grade=" << size_grade << " elem_count=" << store.GetElemCount();
        std::cerr << " --- ptr=" << store.ptr << std::endl;
        std::cerr << "occupieds: ";
        for (int32_t i = 0; i < Steroids::infix_store_target_size; i++) {
            if ((store.ptr[i / 64] >> (i % 64)) & 1ULL)
                std::cerr << i << ' ';
        }
        std::cerr << std::endl << "runends + slots:" << std::endl;;
        int32_t cnt = 0;
        for (int32_t i = 0; i < s.scaled_sizes_[size_grade]; i++) {
            const uint64_t value = s.GetSlot(store, i);
            if (value == 0)
                continue;
            std::cerr << std::setfill(' ') << std::setw(3) << i;
            std::cerr << ',' << ((runends[i / 64] >> (i % 64)) & 1ULL) << ',';
            for (int32_t j = s.infix_size_ - 1; j >= 0; j--)
                std::cerr << ((value >> (j % 64)) & 1ULL);
            std::cerr << "   ";
            if (cnt % 8 == 7)
                std::cerr << std::endl;
            cnt++;
        }
        std::cerr << std::endl;
    }
};

int main(int argc, char **argv) {
    std::cerr << ansi_green << "===== [ Running Tests ]" << ansi_white << std::endl;
    SteroidsTests::InsertionTest();
    std::cerr << ansi_green << "===== [ Done ]" << ansi_white << std::endl;

    return 0;
}

