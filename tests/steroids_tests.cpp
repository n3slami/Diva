/**
 * @file art tests
 * @author ---
 *
 * @author Rafael Kallis <rk@rafaelkallis.com>
 */

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#include "doctest.h"
#include <algorithm>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <string>
#include <tuple>
#include <vector>

#include "steroids.hpp"
#include "util.hpp"

const std::string ansi_green = "\033[0;32m";
const std::string ansi_white = "\033[0;97m";

class SteroidsTests {
public:
    static void InsertionTest() {
        const uint32_t infix_size = 5;
        const uint32_t seed = 1;
        const float load_factor = 0.95;
        Steroids s(infix_size, seed, load_factor);

        uint64_t value;
        uint8_t buf[9];
        memset(buf, 0, sizeof(buf));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000011111111ULL));
        s.AddTreeKey(reinterpret_cast<uint8_t *>(&value), sizeof(value));
        auto it = s.tree_.begin(reinterpret_cast<uint8_t *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000022222222ULL));
        s.AddTreeKey(reinterpret_cast<uint8_t *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000033333333ULL));
        s.AddTreeKey(reinterpret_cast<uint8_t *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000044444444ULL));
        s.AddTreeKey(reinterpret_cast<uint8_t *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000020000000ULL));
        s.Insert(reinterpret_cast<uint8_t *>(&value), sizeof(value));

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000040007777ULL));
        s.Insert(reinterpret_cast<uint8_t *>(&value), sizeof(value));

        for (int32_t i = 1; i < 100; i++) {
            const uint64_t l = 0x0000000011111111ULL, r = 0x0000000022222222ULL;
            const uint64_t interp = (l * i + r * (100 - i)) / 100;
            value = to_big_endian_order(interp);
            s.Insert(reinterpret_cast<uint8_t *>(&value), sizeof(value));
        }
        SUBCASE("interpolated inserts") {
            const std::vector<uint32_t> occupieds_pos = {2, 5, 8, 10, 13, 16,
                19, 21, 24, 27, 30, 32, 35, 38, 41, 43, 46, 49, 51, 54, 57, 60,
                62, 65, 68, 71, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101,
                103, 106, 109, 112, 114, 117, 120, 122, 125, 128, 131, 133,
                136, 139, 142, 144, 147, 150, 152, 155, 158, 161, 163, 166,
                169, 172, 174, 177, 180, 183, 185, 188, 191, 193, 196, 199,
                202, 204, 207, 210, 213, 215, 218, 221, 223, 226, 229, 232,
                234, 237, 239, 240, 243, 245, 248, 251, 254, 256, 259, 262,
                264, 267, 270};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
               {{3,1,0b11001}, {9,1,0b10001}, {15,1,0b01001}, {19,1,0b11111},
                   {25,1,0b10111}, {31,1,0b01111}, {37,1,0b00101},
                   {41,1,0b11101}, {47,1,0b10101}, {53,1,0b01011},
                   {59,1,0b00011}, {62,1,0b11011}, {68,1,0b10011},
                   {74,1,0b01001}, {80,1,0b00001}, {84,1,0b11001},
                   {90,1,0b01111}, {96,1,0b00111}, {100,1,0b11111},
                   {106,1,0b10101}, {112,1,0b01101}, {118,1,0b00101},
                   {121,1,0b11011}, {127,1,0b10011}, {133,1,0b01011},
                   {139,1,0b00011}, {143,1,0b11001}, {149,1,0b10001},
                   {155,1,0b01001}, {159,1,0b11111}, {165,1,0b10111},
                   {171,1,0b01111}, {177,1,0b00101}, {180,1,0b11101},
                   {186,1,0b10101}, {192,1,0b01011}, {198,1,0b00011},
                   {202,1,0b11011}, {208,1,0b10011}, {214,1,0b01001},
                   {220,1,0b00001}, {224,1,0b11001}, {230,1,0b01111},
                   {236,1,0b00111}, {239,1,0b11111}, {245,1,0b10101},
                   {251,1,0b01101}, {257,1,0b00101}, {261,1,0b11011},
                   {267,1,0b10011}, {273,1,0b01011}, {279,1,0b00001},
                   {283,1,0b11001}, {289,1,0b10001}, {295,1,0b01001},
                   {298,1,0b11111}, {304,1,0b10111}, {310,1,0b01111},
                   {316,1,0b00101}, {320,1,0b11101}, {326,1,0b10101},
                   {332,1,0b01011}, {338,1,0b00011}, {342,1,0b11011},
                   {348,1,0b10001}, {354,1,0b01001}, {359,1,0b00001},
                   {363,1,0b11001}, {369,1,0b01111}, {375,1,0b00111},
                   {379,1,0b11111}, {385,1,0b10101}, {391,1,0b01101},
                   {397,1,0b00101}, {401,1,0b11011}, {407,1,0b10011},
                   {413,1,0b01011}, {418,1,0b00001}, {422,1,0b11001},
                   {428,1,0b10001}, {434,1,0b01001}, {438,1,0b11111},
                   {444,1,0b10111}, {450,1,0b01111}, {456,1,0b00101},
                   {460,1,0b11101}, {466,1,0b10101}, {470,1,0b00001},
                   {472,1,0b01011}, {477,1,0b00011}, {481,1,0b11011},
                   {487,1,0b10001}, {493,1,0b01001}, {499,1,0b00001},
                   {503,1,0b10111}, {509,1,0b01111}, {515,1,0b00111},
                   {519,1,0b11111}, {525,1,0b10101}, {531,1,0b01101}};
            assertStoreContents(s, it.ref(), occupieds_pos, checks);
        }

        for (int32_t i = 90; i >= 70; i -= 2) {
            const uint64_t l = 0x0000000011111111ULL, r = 0x0000000022222222ULL;
            const uint64_t interp = (l * i + r * (100 - i)) / 100;
            value = to_big_endian_order(interp);
            s.Insert(reinterpret_cast<uint8_t *>(&value), sizeof(value));
        }
        SUBCASE("overlapping interpolated reversed inserts with a stride of 2") {
            const std::vector<uint32_t> occupieds_pos = {2, 5, 8, 10, 13, 16,
                19, 21, 24, 27, 30, 32, 35, 38, 41, 43, 46, 49, 51, 54, 57, 60,
                62, 65, 68, 71, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101,
                103, 106, 109, 112, 114, 117, 120, 122, 125, 128, 131, 133,
                136, 139, 142, 144, 147, 150, 152, 155, 158, 161, 163, 166,
                169, 172, 174, 177, 180, 183, 185, 188, 191, 193, 196, 199,
                202, 204, 207, 210, 213, 215, 218, 221, 223, 226, 229, 232,
                234, 237, 239, 240, 243, 245, 248, 251, 254, 256, 259, 262,
                264, 267, 270};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                  {{3,1,0b11001}, {9,1,0b10001}, {15,1,0b01001},
                      {19,1,0b11111}, {25,1,0b10111}, {31,1,0b01111},
                      {37,1,0b00101}, {41,1,0b11101}, {47,1,0b10101},
                      {53,0,0b01011}, {54,1,0b01011}, {59,1,0b00011},
                      {62,0,0b11011}, {63,1,0b11011}, {68,1,0b10011},
                      {74,0,0b01001}, {75,1,0b01001}, {80,1,0b00001},
                      {84,0,0b11001}, {85,1,0b11001}, {90,1,0b01111},
                      {96,0,0b00111}, {97,1,0b00111}, {100,1,0b11111},
                      {106,0,0b10101}, {107,1,0b10101}, {112,1,0b01101},
                      {118,0,0b00101}, {119,1,0b00101}, {121,1,0b11011},
                      {127,0,0b10011}, {128,1,0b10011}, {133,1,0b01011},
                      {139,0,0b00011}, {140,1,0b00011}, {143,1,0b11001},
                      {149,0,0b10001}, {150,1,0b10001}, {155,1,0b01001},
                      {159,0,0b11111}, {160,1,0b11111}, {165,1,0b10111},
                      {171,1,0b01111}, {177,1,0b00101}, {180,1,0b11101},
                      {186,1,0b10101}, {192,1,0b01011}, {198,1,0b00011},
                      {202,1,0b11011}, {208,1,0b10011}, {214,1,0b01001},
                      {220,1,0b00001}, {224,1,0b11001}, {230,1,0b01111},
                      {236,1,0b00111}, {239,1,0b11111}, {245,1,0b10101},
                      {251,1,0b01101}, {257,1,0b00101}, {261,1,0b11011},
                      {267,1,0b10011}, {273,1,0b01011}, {279,1,0b00001},
                      {283,1,0b11001}, {289,1,0b10001}, {295,1,0b01001},
                      {298,1,0b11111}, {304,1,0b10111}, {310,1,0b01111},
                      {316,1,0b00101}, {320,1,0b11101}, {326,1,0b10101},
                      {332,1,0b01011}, {338,1,0b00011}, {342,1,0b11011},
                      {348,1,0b10001}, {354,1,0b01001}, {359,1,0b00001},
                      {363,1,0b11001}, {369,1,0b01111}, {375,1,0b00111},
                      {379,1,0b11111}, {385,1,0b10101}, {391,1,0b01101},
                      {397,1,0b00101}, {401,1,0b11011}, {407,1,0b10011},
                      {413,1,0b01011}, {418,1,0b00001}, {422,1,0b11001},
                      {428,1,0b10001}, {434,1,0b01001}, {438,1,0b11111},
                      {444,1,0b10111}, {450,1,0b01111}, {456,1,0b00101},
                      {460,1,0b11101}, {466,1,0b10101}, {470,1,0b00001},
                      {472,1,0b01011}, {477,1,0b00011}, {481,1,0b11011},
                      {487,1,0b10001}, {493,1,0b01001}, {499,1,0b00001},
                      {503,1,0b10111}, {509,1,0b01111}, {515,1,0b00111},
                      {519,1,0b11111}, {525,1,0b10101}, {531,1,0b01101}};
            assertStoreContents(s, it.ref(), occupieds_pos, checks);
        }

        const uint32_t shamt = 16;
        for (int32_t i = 1; i < 50; i++) {
            const uint64_t l = 0x0000000011111111ULL, r = 0x0000000022222222ULL;
            const uint64_t interp = (l * 30 + r * 70) / 100 + (i << shamt);
            value = to_big_endian_order(interp);
            s.Insert(reinterpret_cast<uint8_t *>(&value), sizeof(value));
        }
        SUBCASE("overlapping interpolated consecutive inserts") {
            const std::vector<uint32_t> occupieds_pos = {2, 5, 8, 10, 13, 16,
                19, 21, 24, 27, 30, 32, 35, 38, 41, 43, 46, 49, 51, 54, 57, 60,
                62, 65, 68, 71, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101,
                103, 106, 109, 112, 114, 117, 120, 122, 125, 128, 131, 133,
                136, 139, 142, 144, 147, 150, 152, 155, 158, 161, 163, 166,
                169, 172, 174, 177, 180, 183, 185, 188, 191, 192, 193, 194,
                196, 199, 202, 204, 207, 210, 213, 215, 218, 221, 223, 226,
                229, 232, 234, 237, 239, 240, 243, 245, 248, 251, 254, 256,
                259, 262, 264, 267, 270};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{3,1,0b11001}, {9,1,0b10001}, {15,1,0b01001}, {19,1,0b11111},
                     {25,1,0b10111}, {31,1,0b01111}, {37,1,0b00101},
                     {41,1,0b11101}, {47,1,0b10101}, {53,0,0b01011},
                     {54,1,0b01011}, {59,1,0b00011}, {62,0,0b11011},
                     {63,1,0b11011}, {68,1,0b10011}, {74,0,0b01001},
                     {75,1,0b01001}, {80,1,0b00001}, {84,0,0b11001},
                     {85,1,0b11001}, {90,1,0b01111}, {96,0,0b00111},
                     {97,1,0b00111}, {100,1,0b11111}, {106,0,0b10101},
                     {107,1,0b10101}, {112,1,0b01101}, {118,0,0b00101},
                     {119,1,0b00101}, {121,1,0b11011}, {127,0,0b10011},
                     {128,1,0b10011}, {133,1,0b01011}, {139,0,0b00011},
                     {140,1,0b00011}, {143,1,0b11001}, {149,0,0b10001},
                     {150,1,0b10001}, {155,1,0b01001}, {159,0,0b11111},
                     {160,1,0b11111}, {165,1,0b10111}, {171,1,0b01111},
                     {177,1,0b00101}, {180,1,0b11101}, {186,1,0b10101},
                     {192,1,0b01011}, {198,1,0b00011}, {202,1,0b11011},
                     {208,1,0b10011}, {214,1,0b01001}, {220,1,0b00001},
                     {224,1,0b11001}, {230,1,0b01111}, {236,1,0b00111},
                     {239,1,0b11111}, {245,1,0b10101}, {251,1,0b01101},
                     {257,1,0b00101}, {261,1,0b11011}, {267,1,0b10011},
                     {273,1,0b01011}, {279,1,0b00001}, {283,1,0b11001},
                     {289,1,0b10001}, {295,1,0b01001}, {298,1,0b11111},
                     {304,1,0b10111}, {310,1,0b01111}, {316,1,0b00101},
                     {320,1,0b11101}, {326,1,0b10101}, {332,1,0b01011},
                     {338,1,0b00011}, {342,1,0b11011}, {348,1,0b10001},
                     {354,1,0b01001}, {359,1,0b00001}, {363,1,0b11001},
                     {369,1,0b01111}, {375,0,0b00111}, {376,0,0b01001},
                     {377,0,0b01011}, {378,0,0b01101}, {379,0,0b01111},
                     {380,0,0b10001}, {381,0,0b10011}, {382,0,0b10101},
                     {383,0,0b10111}, {384,0,0b11001}, {385,0,0b11011},
                     {386,0,0b11101}, {387,1,0b11111}, {388,0,0b00001},
                     {389,0,0b00011}, {390,0,0b00101}, {391,0,0b00111},
                     {392,0,0b01001}, {393,0,0b01011}, {394,0,0b01101},
                     {395,0,0b01111}, {396,0,0b10001}, {397,0,0b10011},
                     {398,0,0b10101}, {399,0,0b10111}, {400,0,0b11001},
                     {401,0,0b11011}, {402,0,0b11101}, {403,1,0b11111},
                     {404,0,0b00001}, {405,0,0b00011}, {406,0,0b00101},
                     {407,0,0b00111}, {408,0,0b01001}, {409,0,0b01011},
                     {410,0,0b01101}, {411,0,0b01111}, {412,0,0b10001},
                     {413,0,0b10011}, {414,0,0b10101}, {415,0,0b10111},
                     {416,0,0b11001}, {417,0,0b11011}, {418,0,0b11101},
                     {419,0,0b11111}, {420,1,0b11111}, {421,0,0b00001},
                     {422,0,0b00011}, {423,0,0b00101}, {424,0,0b00111},
                     {425,1,0b01001}, {426,1,0b10101}, {427,1,0b01101},
                     {428,1,0b00101}, {429,1,0b11011}, {430,1,0b10011},
                     {431,1,0b01011}, {432,1,0b00001}, {433,1,0b11001},
                     {434,1,0b10001}, {435,1,0b01001}, {438,1,0b11111},
                     {444,1,0b10111}, {450,1,0b01111}, {456,1,0b00101},
                     {460,1,0b11101}, {466,1,0b10101}, {470,1,0b00001},
                     {472,1,0b01011}, {477,1,0b00011}, {481,1,0b11011},
                     {487,1,0b10001}, {493,1,0b01001}, {499,1,0b00001},
                     {503,1,0b10111}, {509,1,0b01111}, {515,1,0b00111},
                     {519,1,0b11111}, {525,1,0b10101}, {531,1,0b01101}};
            assertStoreContents(s, it.ref(), occupieds_pos, checks);
        }

        value = (0x0000000011111111ULL * 30 + 0x0000000022222222ULL * 70) / 100 + (8ULL << shamt);
        value = to_big_endian_order(value);
        s.InsertSplit({reinterpret_cast<uint8_t *>(&value), sizeof(value)});

        value = to_big_endian_order(static_cast<uint64_t>(0x0000000011111111ULL));
        it = s.tree_.begin(reinterpret_cast<uint8_t *>(&value), sizeof(value));
        SUBCASE("split infix store: left half") {
            const std::vector<uint32_t> occupieds_pos = {5, 11, 16, 21, 27, 32,
                38, 43, 49, 54, 60, 65, 71, 76, 82, 87, 92, 98, 103, 109, 114,
                120, 125, 131, 136, 142, 147, 153, 158, 163, 169, 174, 180,
                185, 191, 196, 202, 207, 213, 218, 224, 229, 234, 240, 245,
                251, 256, 262, 267, 273, 278, 284, 289, 295, 300, 305, 311,
                316, 322, 327, 333, 338, 344, 349, 355, 360, 366, 371, 376,
                382, 383};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{7,1,0b10010}, {15,1,0b00010}, {22,1,0b10010},
                     {29,1,0b11110}, {37,1,0b01110}, {44,1,0b11110},
                     {53,1,0b01010}, {60,1,0b11010}, {68,1,0b01010},
                     {75,0,0b10110}, {76,1,0b10110}, {84,1,0b00110},
                     {91,0,0b10110}, {92,1,0b10110}, {99,1,0b00110},
                     {106,0,0b10010}, {107,1,0b10010}, {115,1,0b00010},
                     {122,0,0b10010}, {123,1,0b10010}, {129,1,0b11110},
                     {137,0,0b01110}, {138,1,0b01110}, {144,1,0b11110},
                     {152,0,0b01010}, {153,1,0b01010}, {159,1,0b11010},
                     {168,0,0b01010}, {169,1,0b01010}, {175,1,0b10110},
                     {183,0,0b00110}, {184,1,0b00110}, {190,1,0b10110},
                     {199,0,0b00110}, {200,1,0b00110}, {206,1,0b10010},
                     {214,0,0b00010}, {215,1,0b00010}, {221,1,0b10010},
                     {228,0,0b11110}, {229,1,0b11110}, {237,1,0b01110},
                     {244,1,0b11110}, {252,1,0b01010}, {259,1,0b11010},
                     {268,1,0b01010}, {275,1,0b10110}, {283,1,0b00110},
                     {290,1,0b10110}, {298,1,0b00110}, {305,1,0b10010},
                     {314,1,0b00010}, {321,1,0b10010}, {328,1,0b11110},
                     {336,1,0b01110}, {343,1,0b11110}, {352,1,0b01010},
                     {359,1,0b11010}, {367,1,0b01010}, {374,1,0b10110},
                     {383,1,0b00110}, {390,1,0b10110}, {398,1,0b00010},
                     {405,1,0b10010}, {414,1,0b00010}, {421,1,0b10010},
                     {428,1,0b11110}, {436,1,0b01110}, {443,1,0b11110},
                     {451,1,0b01010}, {458,1,0b11010}, {467,1,0b01010},
                     {474,1,0b10110}, {482,1,0b00110}, {489,1,0b10110},
                     {498,1,0b00010}, {505,1,0b10010}, {513,1,0b00010},
                     {520,1,0b10010}, {527,1,0b11110}, {530,0,0b01110},
                     {531,0,0b10010}, {532,0,0b10110}, {533,0,0b11010},
                     {534,1,0b11110}, {535,0,0b00010}, {536,0,0b00110},
                     {537,1,0b01010}};
            auto store = it.ref();
            REQUIRE_FALSE(store.IsPartialKey());
            REQUIRE_EQ(store.GetInvalidBits(), 0);
            assertStoreContents(s, store, occupieds_pos, checks);
        }

        value = (0x0000000011111111ULL * 30 + 0x0000000022222222ULL * 70) / 100 + (8ULL << shamt);
        value &= ~BITMASK(shamt);
        value = to_big_endian_order(value);
        it = s.tree_.begin(reinterpret_cast<uint8_t *>(&value), sizeof(value) - shamt / 8);
        SUBCASE("split infix store: right half") {
            const std::vector<uint32_t> occupieds_pos = {0, 1, 2, 3, 4, 5, 6,
                7, 8, 9, 10, 11, 20, 31, 42, 53, 64, 75, 86, 97, 108, 119, 129,
                140, 151, 162, 173, 184, 190, 195, 206, 217, 228, 239, 250,
                260, 271, 282, 293, 304, 315};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{0,1,0b11011}, {1,0,0b00100}, {2,0,0b01100}, {3,0,0b10100},
                     {4,1,0b11100}, {6,0,0b00100}, {7,0,0b01100},
                     {8,0,0b10100}, {9,1,0b11100}, {11,0,0b00100},
                     {12,0,0b01100}, {13,0,0b10100}, {14,1,0b11100},
                     {16,0,0b00100}, {17,0,0b01100}, {18,0,0b10100},
                     {19,1,0b11100}, {21,0,0b00100}, {22,0,0b01100},
                     {23,0,0b10100}, {24,1,0b11100}, {26,0,0b00100},
                     {27,0,0b01100}, {28,0,0b10100}, {29,1,0b11100},
                     {31,0,0b00100}, {32,0,0b01100}, {33,0,0b10100},
                     {34,1,0b11100}, {36,0,0b00100}, {37,0,0b01100},
                     {38,0,0b10100}, {39,1,0b11100}, {41,0,0b00100},
                     {42,0,0b01100}, {43,0,0b10100}, {44,0,0b11100},
                     {45,1,0b11100}, {47,0,0b00100}, {48,0,0b01100},
                     {49,0,0b10100}, {50,1,0b11100}, {52,1,0b00100},
                     {54,1,0b10100}, {56,1,0b10100}, {69,1,0b10100},
                     {87,1,0b01100}, {105,1,0b01100}, {123,1,0b01100},
                     {141,1,0b00100}, {159,1,0b00100}, {177,1,0b00100},
                     {196,1,0b00100}, {212,1,0b11100}, {230,1,0b11100},
                     {248,1,0b11100}, {266,1,0b10100}, {285,1,0b10100},
                     {303,1,0b10100}, {313,1,0b00100}, {321,1,0b01100},
                     {339,1,0b01100}, {357,1,0b01100}, {375,1,0b00100},
                     {393,1,0b00100}, {412,1,0b00100}, {428,1,0b11100},
                     {446,1,0b11100}, {464,1,0b11100}, {482,1,0b11100},
                     {501,1,0b10100}, {519,1,0b10100}};
            auto store = it.ref();
            REQUIRE(store.IsPartialKey());
            REQUIRE_EQ(store.GetInvalidBits(), 0);
            assertStoreContents(s, store, occupieds_pos, checks);
        }

        // Split an extension of a partial boundary key
        const std::string old_boundary = it.key();
        uint32_t extended_key_len = it.key().size() + 1;
        uint8_t extended_key[extended_key_len];
        memcpy(extended_key, it.key().c_str(), extended_key_len);
        extended_key[extended_key_len - 1] = 1;
        s.InsertSplit({extended_key, extended_key_len});

        SUBCASE("split infix store using an extension of a partial boundary key") {
            const std::vector<uint32_t> occupieds_pos = {0, 1, 2, 3, 4, 5, 6,
                7, 8, 9, 10, 11, 20, 31, 42, 53, 64, 75, 86, 97, 108, 119, 129,
                140, 151, 162, 173, 184, 190, 195, 206, 217, 228, 239, 250,
                260, 271, 282, 293, 304, 315};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{0,0,0b11011}, {1,1,0b11011}, {2,0,0b00100}, {3,0,0b01100},
                     {4,0,0b10100}, {5,1,0b11100}, {6,0,0b00100},
                     {7,0,0b01100}, {8,0,0b10100}, {9,1,0b11100},
                     {11,0,0b00100}, {12,0,0b01100}, {13,0,0b10100},
                     {14,1,0b11100}, {16,0,0b00100}, {17,0,0b01100},
                     {18,0,0b10100}, {19,1,0b11100}, {21,0,0b00100},
                     {22,0,0b01100}, {23,0,0b10100}, {24,1,0b11100},
                     {26,0,0b00100}, {27,0,0b01100}, {28,0,0b10100},
                     {29,1,0b11100}, {31,0,0b00100}, {32,0,0b01100},
                     {33,0,0b10100}, {34,1,0b11100}, {36,0,0b00100},
                     {37,0,0b01100}, {38,0,0b10100}, {39,1,0b11100},
                     {41,0,0b00100}, {42,0,0b01100}, {43,0,0b10100},
                     {44,0,0b11100}, {45,1,0b11100}, {47,0,0b00100},
                     {48,0,0b01100}, {49,0,0b10100}, {50,1,0b11100},
                     {52,1,0b00100}, {54,1,0b10100}, {56,1,0b10100},
                     {69,1,0b10100}, {87,1,0b01100}, {105,1,0b01100},
                     {123,1,0b01100}, {141,1,0b00100}, {159,1,0b00100},
                     {177,1,0b00100}, {196,1,0b00100}, {212,1,0b11100},
                     {230,1,0b11100}, {248,1,0b11100}, {266,1,0b10100},
                     {285,1,0b10100}, {303,1,0b10100}, {313,1,0b00100},
                     {321,1,0b01100}, {339,1,0b01100}, {357,1,0b01100},
                     {375,1,0b00100}, {393,1,0b00100}, {412,1,0b00100},
                     {428,1,0b11100}, {446,1,0b11100}, {464,1,0b11100},
                     {482,1,0b11100}, {501,1,0b10100}, {519,1,0b10100}};
            auto store = it.ref();
            REQUIRE(store.IsPartialKey());
            REQUIRE_EQ(store.GetInvalidBits(), 0);
            assertStoreContents(s, store, occupieds_pos, checks);

            REQUIRE_EQ(old_boundary.size(), it.key().size());
            REQUIRE_EQ(memcmp(old_boundary.c_str(), it.key().c_str(), old_boundary.size()), 0);
            it++;
            const uint64_t expected_next_boundary_key = 0x0000000022222222ULL;
            uint64_t current_key = 0;
            memcpy(&current_key, it.key().c_str(), it.key().size());
            REQUIRE_EQ(__bswap_64(current_key), expected_next_boundary_key);
        }

        value = (0x0000000011111111ULL * 30 + 0x0000000022222222ULL * 70) / 100 + (16ULL << shamt);
        value = to_big_endian_order(value);
        s.InsertSplit({reinterpret_cast<uint8_t *>(&value), sizeof(value)});

        it = s.tree_.begin(reinterpret_cast<uint8_t *>(&value), sizeof(value));
        it--;
        SUBCASE("split infix store, create void infixes") {
            const std::vector<uint32_t> occupieds_pos = {0, 1, 2, 3, 4, 5, 6,
                7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
                23, 24, 25, 26, 27, 28, 29, 30, 31};
            const std::vector<std::tuple<uint32_t, bool, uint64_t>> checks =
                 {{0,0,0b10000}, {1,0,0b10000}, {2,0,0b10000}, {3,0,0b10000},
                     {4,0,0b10000}, {5,0,0b10000}, {6,0,0b10000},
                     {7,0,0b10000}, {8,0,0b10000}, {9,1,0b10000},
                     {11,0,0b10000}, {12,0,0b10000}, {13,0,0b10000},
                     {14,0,0b10000}, {15,0,0b10000}, {16,0,0b10000},
                     {17,0,0b10000}, {18,0,0b10000}, {19,0,0b10000},
                     {20,1,0b10000}, {22,0,0b10000}, {23,0,0b10000},
                     {24,0,0b10000}, {25,0,0b10000}, {26,0,0b10000},
                     {27,0,0b10000}, {28,0,0b10000}, {29,0,0b10000},
                     {30,0,0b10000}, {31,1,0b10000}, {33,0,0b10000},
                     {34,0,0b10000}, {35,0,0b10000}, {36,0,0b10000},
                     {37,0,0b10000}, {38,0,0b10000}, {39,0,0b10000},
                     {40,1,0b10000}, {42,0,0b10000}, {43,0,0b10000},
                     {44,0,0b10000}, {45,0,0b10000}, {46,0,0b10000},
                     {47,0,0b10000}, {48,0,0b10000}, {49,1,0b10000},
                     {51,0,0b10000}, {52,0,0b10000}, {53,0,0b10000},
                     {54,0,0b10000}, {55,0,0b10000}, {56,0,0b10000},
                     {57,0,0b10000}, {58,1,0b10000}, {60,0,0b10000},
                     {61,0,0b10000}, {62,0,0b10000}, {63,0,0b10000},
                     {64,0,0b10000}, {65,0,0b10000}, {66,0,0b10000},
                     {67,1,0b10000}, {69,0,0b10000}, {70,0,0b10000},
                     {71,0,0b10000}, {72,0,0b10000}, {73,0,0b10000},
                     {74,0,0b10000}, {75,0,0b10000}, {76,1,0b10000},
                     {78,0,0b10000}, {79,0,0b10000}, {80,0,0b10000},
                     {81,0,0b10000}, {82,0,0b10000}, {83,0,0b10000},
                     {84,0,0b10000}, {85,1,0b10000}, {87,0,0b10000},
                     {88,0,0b10000}, {89,0,0b10000}, {90,0,0b10000},
                     {91,0,0b10000}, {92,0,0b10000}, {93,0,0b10000},
                     {94,1,0b10000}, {96,0,0b10000}, {97,0,0b10000},
                     {98,0,0b10000}, {99,0,0b10000}, {100,0,0b10000},
                     {101,0,0b10000}, {102,0,0b10000}, {103,1,0b10000},
                     {105,0,0b10000}, {106,0,0b10000}, {107,0,0b10000},
                     {108,0,0b10000}, {109,0,0b10000}, {110,0,0b10000},
                     {111,0,0b10000}, {112,1,0b10000}, {114,0,0b10000},
                     {115,0,0b10000}, {116,0,0b10000}, {117,0,0b10000},
                     {118,0,0b10000}, {119,0,0b10000}, {120,0,0b10000},
                     {121,1,0b10000}, {123,0,0b10000}, {124,0,0b10000},
                     {125,0,0b10000}, {126,0,0b10000}, {127,0,0b10000},
                     {128,0,0b10000}, {129,0,0b10000}, {130,1,0b10000},
                     {132,0,0b10000}, {133,0,0b10000}, {134,0,0b10000},
                     {135,0,0b10000}, {136,0,0b10000}, {137,0,0b10000},
                     {138,1,0b10000}, {140,0,0b10000}, {141,0,0b10000},
                     {142,0,0b10000}, {143,0,0b10000}, {144,0,0b10000},
                     {145,0,0b10000}, {146,1,0b10000}, {148,0,0b10000},
                     {149,0,0b10000}, {150,0,0b10000}, {151,0,0b10000},
                     {152,0,0b10000}, {153,0,0b10000}, {154,1,0b10000},
                     {156,0,0b10000}, {157,0,0b10000}, {158,0,0b10000},
                     {159,0,0b10000}, {160,0,0b10000}, {161,0,0b10000},
                     {162,1,0b10000}, {164,0,0b10000}, {165,0,0b10000},
                     {166,0,0b10000}, {167,0,0b10000}, {168,0,0b10000},
                     {169,0,0b10000}, {170,1,0b10000}, {172,0,0b10000},
                     {173,0,0b10000}, {174,0,0b10000}, {175,0,0b10000},
                     {176,0,0b10000}, {177,0,0b10000}, {178,1,0b10000},
                     {180,0,0b10000}, {181,0,0b10000}, {182,0,0b10000},
                     {183,0,0b10000}, {184,0,0b10000}, {185,0,0b10000},
                     {186,1,0b10000}, {188,0,0b10000}, {189,0,0b10000},
                     {190,0,0b10000}, {191,0,0b10000}, {192,0,0b10000},
                     {193,0,0b10000}, {194,1,0b10000}, {196,0,0b10000},
                     {197,0,0b10000}, {198,0,0b10000}, {199,0,0b10000},
                     {200,0,0b10000}, {201,0,0b10000}, {202,1,0b10000},
                     {204,0,0b10000}, {205,0,0b10000}, {206,0,0b10000},
                     {207,0,0b10000}, {208,0,0b10000}, {209,0,0b10000},
                     {210,1,0b10000}, {212,0,0b10000}, {213,0,0b10000},
                     {214,0,0b10000}, {215,0,0b10000}, {216,0,0b10000},
                     {217,0,0b10000}, {218,1,0b10000}, {220,0,0b10000},
                     {221,0,0b10000}, {222,0,0b10000}, {223,0,0b10000},
                     {224,0,0b10000}, {225,0,0b10000}, {226,1,0b10000},
                     {228,0,0b10000}, {229,0,0b10000}, {230,0,0b10000},
                     {231,0,0b10000}, {232,0,0b10000}, {233,0,0b10000},
                     {234,1,0b10000}, {236,0,0b10000}, {237,0,0b10000},
                     {238,0,0b10000}, {239,0,0b10000}, {240,0,0b10000},
                     {241,0,0b10000}, {242,1,0b10000}, {244,0,0b10000},
                     {245,0,0b10000}, {246,0,0b10000}, {247,0,0b10000},
                     {248,0,0b10000}, {249,0,0b10000}, {250,1,0b10000},
                     {252,0,0b10000}, {253,0,0b10000}, {254,0,0b10000},
                     {255,0,0b10000}, {256,0,0b10000}, {257,0,0b10000},
                     {258,1,0b10000}, {260,0,0b10000}, {261,0,0b10000},
                     {262,0,0b10000}, {263,0,0b10000}, {264,0,0b10000},
                     {265,0,0b10000}, {266,1,0b10000}, {268,0,0b10000},
                     {269,0,0b10000}, {270,0,0b10000}, {271,0,0b10000},
                     {272,0,0b10000}, {273,0,0b10000}, {274,1,0b10000}};
            auto store = it.ref();
            REQUIRE(store.IsPartialKey());
            REQUIRE_EQ(store.GetInvalidBits(), 0);
            assertStoreContents(s, store, occupieds_pos, checks);

            REQUIRE_EQ(old_boundary.size(), it.key().size());
            REQUIRE_EQ(memcmp(old_boundary.c_str(), it.key().c_str(), old_boundary.size()), 0);
            it++;
            REQUIRE_EQ(sizeof(value), it.key().size());
            REQUIRE_EQ(memcmp(reinterpret_cast<uint8_t *>(&value), it.key().c_str(), sizeof(value)), 0);
        }
    }

private:
    static void assertStoreContents(const Steroids& s, const Steroids::InfixStore& store,
                                    const std::vector<uint32_t>& occupieds_pos,
                                    const std::vector<std::tuple<uint32_t, bool, uint64_t>>& checks) {
        REQUIRE_NE(store.ptr, nullptr);
        REQUIRE_EQ(store.GetElemCount(), checks.size());
        const uint64_t *occupieds = store.ptr;
        const uint64_t *runends = store.ptr + Steroids::infix_store_target_size / 64;
        uint32_t ind = 0;
        for (uint32_t i = 0; i < Steroids::infix_store_target_size; i++) {
            if (ind < occupieds_pos.size() && i == occupieds_pos[ind]) {
                REQUIRE_EQ(get_bitmap_bit(occupieds, i), 1);
                ind++;
            }
            else 
                REQUIRE_EQ(get_bitmap_bit(occupieds, i), 0);
        }

        const uint32_t total_size = s.scaled_sizes_[store.GetSizeGrade()];
        ind = 0;
        uint32_t runend_count = 0;
        for (int32_t i = 0; i < total_size; i++) {
            const uint64_t slot = s.GetSlot(store, i);
            if (ind < checks.size()) {
                const auto [pos, runend, value] = checks[ind];
                if (i == pos) {
                    REQUIRE_EQ(value, slot);
                    REQUIRE_EQ(get_bitmap_bit(runends, i), runend);
                    runend_count += runend;
                    ind++;
                }
                else {
                    REQUIRE_EQ(slot, 0ULL);
                    REQUIRE_EQ(get_bitmap_bit(runends, i), 0);
                }
            }
            else {
                REQUIRE_EQ(slot, 0ULL);
                REQUIRE_EQ(get_bitmap_bit(runends, i), 0);
            }
        }
        REQUIRE_EQ(occupieds_pos.size(), runend_count);
    }


    static void printStore(const Steroids& s, const Steroids::InfixStore& store) {
        const uint32_t size_grade = store.GetSizeGrade();
        const uint64_t *occupieds = store.ptr;
        const uint64_t *runends = store.ptr + Steroids::infix_store_target_size / 64;

        std::cerr << "is_partial=" << store.IsPartialKey() << " invalid_bits=" << store.GetInvalidBits();
        std::cerr << " size_grade=" << size_grade << " elem_count=" << store.GetElemCount();
        std::cerr << " --- ptr=" << store.ptr << std::endl;
        std::cerr << "occupieds: ";
        for (int32_t i = 0; i < Steroids::infix_store_target_size; i++) {
            if ((store.ptr[i / 64] >> (i % 64)) & 1ULL)
                std::cerr << i << ' ';
        }
        std::cerr << std::endl << "runends + slots:" << std::endl;;
        int32_t cnt = 0;
        for (int32_t i = 0; i < s.scaled_sizes_[size_grade]; i++) {
            const uint64_t value = s.GetSlot(store, i);
            if (value == 0)
                continue;
            std::cerr << std::setfill(' ') << std::setw(3) << i;
            std::cerr << ',' << ((runends[i / 64] >> (i % 64)) & 1ULL) << ',';
            for (int32_t j = s.infix_size_ - 1; j >= 0; j--)
                std::cerr << ((value >> (j % 64)) & 1ULL);
            std::cerr << "   ";
            if (cnt % 8 == 7)
                std::cerr << std::endl;
            cnt++;
        }
        std::cerr << std::endl;
    }
};

TEST_SUITE("steroids") {
    TEST_CASE("insertion") {
        SteroidsTests::InsertionTest();
    }
}

