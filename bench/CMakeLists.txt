cmake_minimum_required(VERSION 3.16.3)
project(range-filter-bench)

# fetch latest argparse
include(FetchContent)
FetchContent_Declare(
    argparse
    GIT_REPOSITORY https://github.com/p-ranav/argparse.git
    GIT_TAG        v2.7
)
FetchContent_MakeAvailable(argparse)

set(CMAKE_CXX_STANDARD 17)

list(APPEND SUCCINCT_LIBS "sux" "sdsl-lite")
list(APPEND Targets "diva" "diva_int" "memento" "memento_expandable" "grafite" "surf" "rosetta" "proteus" "rencoder" "snarf" "oasis")
list(APPEND WiredTigerTargets "diva" "diva_int" "memento_expandable" "base")
list(APPEND x86Targets "diva" "diva_int" "memento" "memento_expandable" "surf" "rosetta" "proteus" "rencoder" "oasis")

set(MEMENTO_COMPILE_FLAGS -Ofast -msse4.2 -D__SSE4_2_)

function(compile_bench ds)
    if (NOT ds IN_LIST Targets)
        message(WARNING "${ds} is not defined")
        return()
    endif()
    if (ds IN_LIST x86Targets AND NOT CMAKE_SYSTEM_PROCESSOR MATCHES "(x86)|(X86)|(amd64)|(AMD64)")
        message(WARNING "cannot compile ${ds} on this architecture")
        return()
    endif()
    add_executable(bench_${ds} filter_benchmarks/${ds}.cpp)
    target_link_libraries(bench_${ds} argparse)

    if (ds MATCHES "diva")
        target_link_libraries(bench_${ds} DivaLib)
    elseif (ds MATCHES "memento")
        if (ds STREQUAL "memento")
            add_library(MementoLib STATIC ./include/memento/src/memento.c ./include/memento/src/hashutil.c)
            target_include_directories(MementoLib PUBLIC ./include/memento/include/)
            target_compile_options(MementoLib PUBLIC ${MEMENTO_COMPILE_FLAGS})
            target_link_libraries(bench_memento MementoLib)
        elseif (ds STREQUAL "memento_expandable")
            add_library(MementoExpandableLib STATIC ./include/memento_expandable/src/memento.c ./include/memento_expandable/src/hashutil.c)
            target_include_directories(MementoExpandableLib PUBLIC ./include/memento_expandable/include/)
            target_compile_options(MementoExpandableLib PUBLIC ${MEMENTO_COMPILE_FLAGS})
            target_link_libraries(bench_memento_expandable MementoExpandableLib)
        endif ()


        set(Boost_USE_STATIC_LIBS OFF)
        set(Boost_USE_STATIC_RUNTIME OFF)
        if (USE_BOOST AND USE_MULTI_THREADED)
            set(Boost_USE_MULTITHREADED ON)
            find_package(Boost REQUIRED COMPONENTS thread)
            message(STATUS "Boost found, using it for the multi-threaded version of the library")
            target_compile_definitions(bench_${ds} INTERFACE -DUSE_LIBRARY_BOOST_PARALLEL)
            target_link_libraries(bench_${ds} INTERFACE Boost::thread)
            target_include_directories(bench_${ds} INTERFACE ${Boost_INCLUDE_DIRS})
        elseif (USE_BOOST)
            set(Boost_USE_MULTITHREADED OFF)
            find_package(Boost REQUIRED)
            message(STATUS "Boost found, using it for the single-threaded version of the library")
            target_compile_definitions(bench_${ds} INTERFACE -DUSE_LIBRARY_BOOST)
            target_include_directories(bench_${ds} INTERFACE ${Boost_INCLUDE_DIRS})
        elseif (USE_MULTI_THREADED)
            message(STATUS "Using TBB and std::execution for the multi-threaded version of the library")
            find_package(TBB REQUIRED)
            target_compile_definitions(bench_${ds} INTERFACE -DUSE_LIBRARY_STL_PARALLEL)
            target_link_libraries(bench_${ds} INTERFACE tbb)
        endif ()

    elseif (ds STREQUAL "grafite")
        add_library(grafitelib INTERFACE)

        if ("sux" IN_LIST SUCCINCT_LIBS)
            message(STATUS "Using sux")
            target_compile_definitions(grafitelib INTERFACE -DSUCCINCT_LIB_SUX)
            target_include_directories(grafitelib INTERFACE ./include/grafite/include ./include/grafite/lib/sux)
        endif()
        if ("sdsl-lite" IN_LIST SUCCINCT_LIBS)
            message(STATUS "Using sdsl-lite")
            target_compile_definitions(grafitelib INTERFACE -DSUCCINCT_LIB_SDSL)
            target_include_directories(grafitelib INTERFACE ./include/grafite/include ./include/grafite/lib/sdsl-lite/include)
        endif()

        set(Boost_USE_STATIC_LIBS OFF)
        set(Boost_USE_STATIC_RUNTIME OFF)
        if (USE_BOOST AND USE_MULTI_THREADED)
            set(Boost_USE_MULTITHREADED ON)
            find_package(Boost REQUIRED COMPONENTS thread)
            message(STATUS "Boost found, using it for the multi-threaded version of the library")
            target_compile_definitions(grafitelib INTERFACE -DUSE_LIBRARY_BOOST_PARALLEL)
            target_link_libraries(grafitelib INTERFACE Boost::thread)
            target_include_directories(grafitelib INTERFACE ${Boost_INCLUDE_DIRS})
        elseif (USE_BOOST)
            set(Boost_USE_MULTITHREADED OFF)
            find_package(Boost REQUIRED)
            message(STATUS "Boost found, using it for the single-threaded version of the library")
            target_compile_definitions(grafitelib INTERFACE -DUSE_LIBRARY_BOOST)
            target_include_directories(grafitelib INTERFACE ${Boost_INCLUDE_DIRS})
        elseif (USE_MULTI_THREADED)
            message(STATUS "Using TBB and std::execution for the multi-threaded version of the library")
            find_package(TBB REQUIRED)
            target_compile_definitions(grafitelib INTERFACE -DUSE_LIBRARY_STL_PARALLEL)
            target_link_libraries(grafitelib INTERFACE tbb)
        endif ()

        target_link_libraries(bench_grafite grafitelib)
    elseif (ds STREQUAL "rosetta")
        add_library(rosetta STATIC ./include/rosetta/dst.cpp ./include/rosetta/MurmurHash3.cpp)
        target_link_libraries(bench_rosetta rosetta)
    elseif(ds STREQUAL "proteus")
        add_library(proteus STATIC ./include/proteus/include/config.cpp 
                                   ./include/proteus/include/clhash.cpp 
                                   ./include/proteus/include/prefixbf.cpp 
                                   ./include/proteus/include/MurmurHash3.cpp 
                                   ./include/proteus/include/util.cpp 
                                   ./include/proteus/include/modeling.cpp)
        target_compile_options(proteus PUBLIC -march=native)
        target_link_libraries(bench_proteus proteus)
    elseif(ds STREQUAL "snarf" AND NOT CMAKE_SYSTEM_PROCESSOR MATCHES "(x86)|(X86)|(amd64)|(AMD64)")
        link_directories("/opt/homebrew/lib")
        include_directories("/opt/homebrew/include")
    elseif(ds STREQUAL "rencoder")
        # Not using SIMD makes it faster for some reason
        #target_compile_definitions(bench_rencoder PRIVATE USE_SIMD=1)
        target_compile_options(bench_rencoder PRIVATE -mcmodel=medium -mavx512f -O2)
    elseif(ds STREQUAL "oasis")
        add_subdirectory(./include/oasis/)
        target_include_directories(OasisPlus PUBLIC ./include/oasis/src/include 
                                                    ./include/oasis/src/learned_rf 
                                                    ./include/oasis/src/proteus 
                                                    ./include/oasis/oasis)
        target_link_libraries(bench_oasis OasisPlus)
    endif()
endfunction(compile_bench)

function(compile_bench_wiredtiger ds)
    if (NOT ds IN_LIST WiredTigerTargets)
        message(WARNING "${ds} is not defined")
        return()
    endif()
    if (ds IN_LIST x86Targets AND NOT CMAKE_SYSTEM_PROCESSOR MATCHES "(x86)|(X86)|(amd64)|(AMD64)")
        message(WARNING "cannot compile ${ds} on this architecture")
        return()
    endif()
    add_executable(bench_${ds}_wiredtiger wiredtiger_benchmarks/${ds}.cpp)
    target_include_directories(bench_${ds}_wiredtiger PUBLIC ./wiredtiger/build/include)
    target_link_libraries(bench_${ds}_wiredtiger argparse ${WIREDTIGER_LIB})

    if (ds MATCHES "diva")
        target_link_libraries(bench_${ds}_wiredtiger DivaLib)
    elseif (ds STREQUAL "memento_expandable")
        target_link_libraries(bench_memento_expandable_wiredtiger MementoExpandableLib)

        set(Boost_USE_STATIC_LIBS OFF)
        set(Boost_USE_STATIC_RUNTIME OFF)
        if (USE_BOOST AND USE_MULTI_THREADED)
            set(Boost_USE_MULTITHREADED ON)
            find_package(Boost REQUIRED COMPONENTS thread)
            message(STATUS "Boost found, using it for the multi-threaded version of the library")
            target_compile_definitions(bench_${ds}_wiredtiger INTERFACE -DUSE_LIBRARY_BOOST_PARALLEL)
            target_link_libraries(bench_${ds}_wiredtiger INTERFACE Boost::thread)
            target_include_directories(bench_${ds}_wiredtiger INTERFACE ${Boost_INCLUDE_DIRS})
        elseif (USE_BOOST)
            set(Boost_USE_MULTITHREADED OFF)
            find_package(Boost REQUIRED)
            message(STATUS "Boost found, using it for the single-threaded version of the library")
            target_compile_definitions(bench_${ds}_wiredtiger INTERFACE -DUSE_LIBRARY_BOOST)
            target_include_directories(bench_${ds}_wiredtiger INTERFACE ${Boost_INCLUDE_DIRS})
        elseif (USE_MULTI_THREADED)
            message(STATUS "Using TBB and std::execution for the multi-threaded version of the library")
            find_package(TBB REQUIRED)
            target_compile_definitions(bench_${ds}_wiredtiger INTERFACE -DUSE_LIBRARY_STL_PARALLEL)
            target_link_libraries(bench_${ds}_wiredtiger INTERFACE tbb)
        endif ()
    elseif (ds STREQUAL "base")
    endif()
endfunction(compile_bench)

foreach(ds ${Targets})
    compile_bench(${ds})
endforeach()

find_library(WIREDTIGER_LIB NAMES wiredtiger libwiredtiger PATHS ./wiredtiger/build/)
foreach(ds ${WiredTigerTargets})
    compile_bench_wiredtiger(${ds})
endforeach()

# Setup workload generation binary
add_executable(workload_gen workload_gen.cpp)
target_link_libraries(workload_gen argparse)

